<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html lang="en-gb">



<head>
<meta http-equiv="Content-Type" content="text/html; charset=windows-1252">

<title>ScriptSite - ATL Active Script Engine Wrapper - VisionTech Limited</title>
<meta name="keywords" content="active script,activex,scripting,vbscript,javascript,COM,ATL,visual c++">
<meta name="description" content="An ATL include file to assist hosting an active script engine in your project.">

<link rel="stylesheet" type="text/css" href="../style/style.css">
<meta name="revisit-after" content="1 days">
<meta name="robots" content="all">
<link rel="alternate" type="application/rss+xml" title="RSS" href="../rss/rss.aspx">
</head>

<body>
<div id="branding"></div>
<div id="logo"></div>
<div id="menu"></div>

<div id="bodycontent">

<H1>ATL Active Script Engine Wrapper</H1>

<P><A HREF="download/ScriptSite.zip">Download</A>&nbsp;&nbsp;&#183;&nbsp;&nbsp;<A HREF="download/ScriptSite.h.html" TARGET="_blank">View Source Code</A> (link opens new window)</P>

<P>Microsoft did us a favour when they produced Active Scripting. We can readily add
scripting facilities to our applications with practically no effort compared to what
was required just a few years ago.</P>

<P>I've included scripting in a few applications and each time modified the previous
copy of my code to fit the new requirements. Having decided this time to construct
a more reusable wrapper and to make use of ATL, I decided to share the results of my
efforts to save others some time.</P>

<P>At the heart of the code is the <TT>CScriptSiteImpl</TT> class. This is the base class
from which you need to inherit for your project. I've included a minimal class
<TT>CScriptSiteBasic</TT> (which you can use directly) that demonstrates what you
need to do to use the code:</P>

<P><PRE>    <font color="#0000ff">class</font> ATL_NO_VTABLE CScriptSiteBasic :
        <font color="#0000ff">public</font> CComObjectRootEx&lt;CComSingleThreadModel&gt;,
        <font color="#0000ff">public</font> CScriptSiteImpl
    {
    <font color="#0000ff">public</font>:
    DECLARE_PROTECT_FINAL_CONSTRUCT()
    BEGIN_COM_MAP(CScriptSiteBasic)
        COM_INTERFACE_ENTRY(IActiveScriptSite)
        COM_INTERFACE_ENTRY(IActiveScriptSiteWindow)
    END_COM_MAP()
    };</PRE></P>

<P>To make use of this class, just use code as follows:</P>

<P><PRE>    LPCTSTR strScriptCode; <font color="#008000"><i>// this points to the script code we want to run</i></font>
    ...
    CComObject&lt;CScriptSiteBasic&gt;* pBasic;
    CComQIPtr&lt;IActiveScriptSite&gt; spUnk;
    HR(CComObject&lt;CScriptSiteBasic&gt;::CreateInstance(&amp;pBasic));
    spUnk = pBasic; <font color="#008000"><i>// let CComQIPtr tidy up for us</i></font>
    HR(pBasic-&gt;Initiate(_T(<font color="#ff00ff">&quot;jscript&quot;</font>),GetDesktopWindow()));
    HR(pBasic-&gt;AddScript(strScriptCode));
    HR(pBasic-&gt;Run());
    HR(pBasic-&gt;Terminate());</PRE></P>

<P>You will more than likely want to include your own object model within the script engine.
To do this, you will need to create your own class derived from <TT>CScriptSiteImpl</TT> in the
same fashion as <TT>CScriptSiteBasic</TT> above.</P> You will need to call
<TT>CScriptSiteImpl::AddObject</TT> once for each object to tell the script engine the names
used in your model. Next, you will need to provide your own implementation of
<TT>LookupNamedItem</TT> as follows:

<P><PRE>    <font color="#008000"><i>// Override this method in your implementation and return the desired object
    // or TYPE_E_ELEMENTNOTFOUND if the name doesn't match one of yours
    // (You must call CScriptSiteImpl::AddObject in the first place to tell
    // the script engine that your objects exist).</i></font>
    STDMETHOD(LookupNamedItem)(LPCOLESTR pstrName,LPUNKNOWN* ppunkItem)
    {
        <font color="#0000ff">return</font> TYPE_E_ELEMENTNOTFOUND;
    }</PRE></P>

<P>You need to check the value of pstrName and return the corresponding IUnknown interface
for that object. Of course, the object must implement IDispatch because the script engines
are late bound. If the name doesn't match one of your objects, return TYPE_E_ELEMENTNOTFOUND.</P>

<P>Finally, to include your own error handler, you need to override <TT>HandleScriptError</TT>:</P>

<P><PRE>    <font color="#008000"><i>// Override this method in your implementation to handle error messages</i></font>
    STDMETHOD(HandleScriptError)(EXCEPINFO* pei,ULONG ulLine,LONG lPos,BSTR src)
    {
        ...
        ...
        <font color="#0000ff">return</font> NOERROR;
    }</PRE></P>

<P><TT>pei</TT> points to the EXCEPINFO structure for the error, <TT>ulLine</TT>
and <TT>lPos</TT> indicate the line and column in your source script where the
error occurred, and <TT>src</TT> contains a copy of that source script line.</P>

<P><A HREF="download/ScriptSite.zip">Download</A>&nbsp;&nbsp;&#183;&nbsp;&nbsp;<A HREF="download/ScriptSite.h.html" TARGET="_blank">View Source Code</A> (link opens new window)</P>

	</div>

<div id="leftcontent">&nbsp;</div>

</body>



</html>